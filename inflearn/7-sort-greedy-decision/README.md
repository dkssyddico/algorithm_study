# 정렬과 그리디, 결정알고리즘(이분검색)

> 정렬 문제는 나중에 한 번 다시 쭉 훑어보자!

## 1. 선택정렬

## 21.07.23

### 👩🏻‍💻 My solution

sort 이용해서 품

### 👨‍🏫 Teacher's solution

i번째로 올 수 있는 숫자를 다 탐색해 선택해서 바꿔주는 것 = 선택정렬
이중 for문으로 한다.
i는 인덱스 0번부터 끝까지 돈다.
j는 i 뒷편부터 돈다.
i번째에 있는 아이템에 올 제일 작은 숫자를 0번부터 끝까지 돌아 찾아서 i번째에 갖다놓는다.
idx 변수에 제일 작은 숫자를 지정. 0부터 시작한다.
arr[j]값과 arr[idx]값을 비교한 뒤 arr[j] 값이 더 작으면 idx를 j로 바꾼다.
그리고 arr[i]와 arr[idx] 를 배열에서 순서를 바꾸는데,
arr[idx]를 왼쪽으로 갈 수 있도록 순서를 바꾼다.

---

<br>

## 2. 버블정렬

## 21.07.24

### 👩🏻‍💻 My solution

앞의 선택 정렬과 비슷하게 구현했는데 배열 내에서 정렬되지 않는 부분이 여전히 남아있다.
이걸 어떻게 되돌아가서 다시 비교 정렬을 할 수 있을까?
무언가 초기화시켜줘야할 듯. 다시 돌아갈 수 있도록.
그리고 다 정렬되었다는 것을 어떻게 확인할 수 있을까?

### 👨‍🏫 Teacher's solution

이웃한 두 아이템을 비교해서 작은 수를 왼쪽으로 보내주는 것.
이중 for문을 도는데 i는 배열의 전체를 돌 바퀴수.
j는 아이템을 비교하는 index. -> 여기까지 설명듣고 내가 직접 풀었따!! 푸니까 허탈감이..
(추가설명) j가 꼭 배열의 길이까지 돌아야 할 필요는 없다.
앞 뒤 비교이기때문에 배열의 길이에서 i를 빼주고 1을 한 번 더 빼주면 된다.
j = 0 ~ 배열의 길이 - i - 1
뒷쪽의 자리가 점점 정해지므로 줄여줘야 한다. -> 내 2번째 풀이처럼 다 돌 필요는 없다.(i)

---

<br>

## 3. Special Sort(버블정렬응용)

## 21.07.25

### 👩🏻‍💻 My solution

문제를 제대로 안읽어서 그냥 단순한 숫자 정렬인줄 알았다.

### 👨‍🏫 Teacher's solution

버블 정렬과 같으나 문제 조건 대로 하려면!
앞의 아이템은 양수여야 하고 뒤의 아이템은 음수여야 한다.

```js
if (arr[j] > 0 && arr[j + 1] < 0)
```

이렇게 해야 양수, 음수들끼리는 대소비교하지 않고 음수와 양수가 배열에 있는 순서대로 정렬된다.

---

<br>

## 4. 삽입정렬

## 21.07.26

### 👩🏻‍💻 My solution

임시 변수를 만들어야겠다는 생각을 했는데 풀지는 못함 🥲

### 👨‍🏫 Teacher's solution

이중 for문을 돌린다.
i는 1부터 시작한다.
tmp 변수를 만들어 arr[i] 값을 넣는다.
j는 i-1로 시작한다. 기준값과 기준값 앞 아이템 대소를 비교하기 위해서.
arr[j]가 tmp보다 크면 arr[j+1] = arr[j]. 큰 수를 더 뒷자리로 넣는 것.
arr[j]가 tmp보다 작으면 break.
j가 다 줄어들었을 때 + 1을 해줘서 tmp 값이 들어가도록 한다.

---

<br>

## 5. LRU(카카오 캐시 변형 : 삽입정렬응용)

## 21.07.27

### 👩🏻‍💻 My solution

삽입정렬 말고 array의 `unshift`와 `pop`으로 풀어버렸다 🥲
문제를 잘못읽음. 위처럼 풀면 안될 거 같음. 배열에 작업하고 있는 숫자가 있으면 빠져야함

### 👨‍🏫 Teacher's solution

하나씩 땡겨오는 것이 관건!

1. 첫번째 방법
   pos라는 변수에 -1을 넣어준다.
   먼저 answer 배열에 작업 중인 숫자가 있는지 찾는다.
   만약에 기존재하는 숫자가 있다면 pos는 index를 받는다.
   만약에 pos가 -1이면 찾는 숫자가 배열 내에 존재하지 않았다는 것이므로,
   숫자가 뒤로 하나씩 당겨지고, 배열 맨 앞의 값은 찾는 숫자가 된다.
   그리고 만약 pos의 값이 index가 된다면,
   pos가 i가 되어 i가 0이 될 때까지 배열 내 pos번의 아이템은 앞 자리 아이템 숫자를 당겨온다.
   즉, pos번의 아이템은 pos - 1번 아이템의 값을 가져와 기존 값이 사라진다.
   직접 손으로 해보니까 이해가 더 잘감.

2. 두번째 방법: 배열 내장함수 unshift, splice, pop 이용
   pos 변수를 이용하는 것과 배열에서 찾는 숫자가 있는지 판별하는 거 까지는 같다.
   다만 pos가 -1일 때,(= 찾는 숫자가 없을 경우)
   값을 배열의 맨 앞에 넣어준다.
   그리고 배열이 요구하는 사이즈보다 길어지면 pop으로 잘라준다.
   pos값이 -1이 아니면 pos는 index 값을 새로 받으므로,
   splice를 이용해 pos 값으로 배열에서 하나를 잘라준다.
   이 값이 중복값이고 중복값을 빼주는 것이다.
   그리고 추가할 값을 값을 배열 맨 앞에 추가한다.

---

<br>

## 6. 장난꾸러기 현수

## 21.07.28

### 👩🏻‍💻 My solution

원래대로여야 할 정렬과 현수가 짝꿍과 자리 바꾼 정렬을 비교해서 다른 값을 answer에 넣는다.

### 👨‍🏫 Teacher's solution

선생님이 한 방법도 내가 한 방법이랑 같음.
다른 점은 arr를 어떻게 복사해와서 쓰느냐.

```js
let sortArr = arr.slice();
```

slice를 쓰면 원본은 수정되지 않고 다 받아올 수 있다.

---

<br>

## 7. 좌표 정렬

## 21.07.29

### 👩🏻‍💻 My solution

sort를 써서 간단하게 풀 수 있다!

### 👨‍🏫 Teacher's solution

---

<br>

## 8. 회의실 배정

## 21.07.30

### 👩🏻‍💻 My solution

전역 변수와 지역 변수를 어떻게 써야할 지 헷갈려서 고생한 문제.
초기화시켜주고 값을 새로 할당하는 게 아직은 많이 헷갈렸음 ㅠㅠ
모든 경우의 수를 계산해야 하므로 배열의 index 순서대로 돌 수 있도록 while문을 먼저 썼다.
그리고 두 값을 비교해야해서 이중 for문을 썼음.
tmp라는 임시 배열을 만들고 초기화 해주는게 포인트였다. (1차 헷갈림)
왜냐면 배열의 가장 긴 길이가 최댓값이기 때문에 배열의 순서대로 돌린 값을 임시 배열에 넣어주고 최종 길이들을 비교해야 하기 때문이다.
두번째 헷갈린거는 처음에 회의 끝시간을 어떻게 구해줄 것이냐.
a로 설정했는데 a는 while문의 i를 따라가야 한다.
왜냐 차례대로 하는 계산이기 때문에.
while문이 돌아가는 이상 for문에서 a를 선언해버리면 계속 같은 값만 나온다.
그리고 b는 a의 뒷아이템 부터 비교해주는 것이기 때문에 b는 a+1을 한다.
그리고 회의 끝시간 end와 회의 시작시간인 start가 같으면 임시 배열에 회의 시작시간의 배열을 넣어준다.
약간 chain처럼 얽혀서 들어가야한다고 이해했다.
그래서 최초에는 시작하는 값을 넣고 그 시작하는 값의 회의 끝시간과 값이 같은 회의 첫시간을 가진 배열을 차례로 넣어주는 것.
그리고 3차 헷갈림은 a값을 재할당해줘야한다는 것이었다.
그냥 두면 a는 for문에 의해서 +1씩 증가한다.
그러나 a는 chain으로 얽혀있는 다음 배열의 인덱스를 가져서 해당 배열이 된 뒤 끝시간을 가지고 다음 순서의 회의 첫시간을 비교해줘야하기 때문.
그래서 `a = b - 1` 이라고 해주고 break를 해주면 for문이 끝나 a++가 되므로 결국 b 값 인덱스를 가진 배열 내 아이템이 된다.
그런 다음엔 계속 위의 값이 반복되고,
이중 for 문이 끝난 후에는 임시 배열의 길이 값을 max와 비교한뒤 큰 값이 max가 되도록한다.

- arr를 시작 시간으로 sort 해서 답이 나옴

### 👨‍🏫 Teacher's solution

**그리디 문제**
정렬을 먼저 하는데 회의가 일찍 끝나는 것이 우선이다.
끝나는 시간으로 정렬을 해야 더 많이 회의를 할 수 있다.
[2, 3], [1, 4], [3, 5], [4, 6], [5, 7]
대신 끝나는 시간이 같을 수도 있으니 그럼 시작하는 시간으로 비교한다.
처음에 endtime(et)을 0으로 잡고, 배열을 for문으로 돈다.
배열 아이템의 시작 시간이 et보다 크면 1을 더해주고 endtime을 배열의 회의 끝나는 시간으로 재할당한다.
그러면 이제 인덱스 1부터는 회의 끝나는 시간과 2의 시작시간이 같은지 혹은 더 큰지 여부를 비교할 수 있다.
선생님 코드가 훨씬 짧은걸 보니 허탈.. 그리디에 대해서 공부해야겠다.

---

<br>

## 9. 결혼식

## 21.07.31

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 10. 이분검색

## 21.08.01

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 11. 뮤직비디오(결정알고리즘)

## 21.08.02

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 12. 마구간 정하기(결정알고리즘)

## 21.08.03

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>
