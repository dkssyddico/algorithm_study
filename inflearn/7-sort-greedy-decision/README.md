# 정렬과 그리디, 결정알고리즘(이분검색)

> 정렬 문제는 나중에 한 번 다시 쭉 훑어보자!

## 1. 선택정렬

## 21.07.23

### 👩🏻‍💻 My solution

sort 이용해서 품

### 👨‍🏫 Teacher's solution

i번째로 올 수 있는 숫자를 다 탐색해 선택해서 바꿔주는 것 = 선택정렬
이중 for문으로 한다.
i는 인덱스 0번부터 끝까지 돈다.
j는 i 뒷편부터 돈다.
i번째에 있는 아이템에 올 제일 작은 숫자를 0번부터 끝까지 돌아 찾아서 i번째에 갖다놓는다.
idx 변수에 제일 작은 숫자를 지정. 0부터 시작한다.
arr[j]값과 arr[idx]값을 비교한 뒤 arr[j] 값이 더 작으면 idx를 j로 바꾼다.
그리고 arr[i]와 arr[idx] 를 배열에서 순서를 바꾸는데,
arr[idx]를 왼쪽으로 갈 수 있도록 순서를 바꾼다.

---

<br>

## 2. 버블정렬

## 21.07.24

### 👩🏻‍💻 My solution

앞의 선택 정렬과 비슷하게 구현했는데 배열 내에서 정렬되지 않는 부분이 여전히 남아있다.
이걸 어떻게 되돌아가서 다시 비교 정렬을 할 수 있을까?
무언가 초기화시켜줘야할 듯. 다시 돌아갈 수 있도록.
그리고 다 정렬되었다는 것을 어떻게 확인할 수 있을까?

### 👨‍🏫 Teacher's solution

이웃한 두 아이템을 비교해서 작은 수를 왼쪽으로 보내주는 것.
이중 for문을 도는데 i는 배열의 전체를 돌 바퀴수.
j는 아이템을 비교하는 index. -> 여기까지 설명듣고 내가 직접 풀었따!! 푸니까 허탈감이..
(추가설명) j가 꼭 배열의 길이까지 돌아야 할 필요는 없다.
앞 뒤 비교이기때문에 배열의 길이에서 i를 빼주고 1을 한 번 더 빼주면 된다.
j = 0 ~ 배열의 길이 - i - 1
뒷쪽의 자리가 점점 정해지므로 줄여줘야 한다. -> 내 2번째 풀이처럼 다 돌 필요는 없다.(i)

---

<br>

## 3. Special Sort(버블정렬응용)

## 21.07.25

### 👩🏻‍💻 My solution

문제를 제대로 안읽어서 그냥 단순한 숫자 정렬인줄 알았다.

### 👨‍🏫 Teacher's solution

버블 정렬과 같으나 문제 조건 대로 하려면!
앞의 아이템은 양수여야 하고 뒤의 아이템은 음수여야 한다.

```js
if (arr[j] > 0 && arr[j + 1] < 0)
```

이렇게 해야 양수, 음수들끼리는 대소비교하지 않고 음수와 양수가 배열에 있는 순서대로 정렬된다.

---

<br>

## 4. 삽입정렬

## 21.07.26

### 👩🏻‍💻 My solution

임시 변수를 만들어야겠다는 생각을 했는데 풀지는 못함 🥲

### 👨‍🏫 Teacher's solution

이중 for문을 돌린다.
i는 1부터 시작한다.
tmp 변수를 만들어 arr[i] 값을 넣는다.
j는 i-1로 시작한다. 기준값과 기준값 앞 아이템 대소를 비교하기 위해서.
arr[j]가 tmp보다 크면 arr[j+1] = arr[j]. 큰 수를 더 뒷자리로 넣는 것.
arr[j]가 tmp보다 작으면 break.
j가 다 줄어들었을 때 + 1을 해줘서 tmp 값이 들어가도록 한다.

---

<br>

## 5. LRU(카카오 캐시 변형 : 삽입정렬응용)

## 21.07.27

### 👩🏻‍💻 My solution

삽입정렬 말고 array의 `unshift`와 `pop`으로 풀어버렸다 🥲
문제를 잘못읽음. 위처럼 풀면 안될 거 같음. 배열에 작업하고 있는 숫자가 있으면 빠져야함

### 👨‍🏫 Teacher's solution

하나씩 땡겨오는 것이 관건!

1. 첫번째 방법
   pos라는 변수에 -1을 넣어준다.
   먼저 answer 배열에 작업 중인 숫자가 있는지 찾는다.
   만약에 기존재하는 숫자가 있다면 pos는 index를 받는다.
   만약에 pos가 -1이면 찾는 숫자가 배열 내에 존재하지 않았다는 것이므로,
   숫자가 뒤로 하나씩 당겨지고, 배열 맨 앞의 값은 찾는 숫자가 된다.
   그리고 만약 pos의 값이 index가 된다면,
   pos가 i가 되어 i가 0이 될 때까지 배열 내 pos번의 아이템은 앞 자리 아이템 숫자를 당겨온다.
   즉, pos번의 아이템은 pos - 1번 아이템의 값을 가져와 기존 값이 사라진다.
   직접 손으로 해보니까 이해가 더 잘감.

2. 두번째 방법: 배열 내장함수 unshift, splice, pop 이용
   pos 변수를 이용하는 것과 배열에서 찾는 숫자가 있는지 판별하는 거 까지는 같다.
   다만 pos가 -1일 때,(= 찾는 숫자가 없을 경우)
   값을 배열의 맨 앞에 넣어준다.
   그리고 배열이 요구하는 사이즈보다 길어지면 pop으로 잘라준다.
   pos값이 -1이 아니면 pos는 index 값을 새로 받으므로,
   splice를 이용해 pos 값으로 배열에서 하나를 잘라준다.
   이 값이 중복값이고 중복값을 빼주는 것이다.
   그리고 추가할 값을 값을 배열 맨 앞에 추가한다.

---

<br>

## 6. 장난꾸러기 현수

## 21.07.28

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 7. 좌표 정렬

## 21.07.29

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 8. 회의실 배정

## 21.07.30

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 9. 결혼식

## 21.07.31

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 10. 이분검색

## 21.08.01

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 11. 뮤직비디오(결정알고리즘)

## 21.08.02

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>

## 12. 마구간 정하기(결정알고리즘)

## 21.08.03

### 👩🏻‍💻 My solution

### 👨‍🏫 Teacher's solution

---

<br>
