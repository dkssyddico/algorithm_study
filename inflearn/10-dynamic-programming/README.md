# Dynamic programming(동적계획법)

## 1. 계단오르기

## 21.08.27

### My solution 👩🏻‍💻

### Teacher's solution 👨‍🏫

**동적 계획법**은 한 번에 풀기는 어려운 문제를 작은 단위의 문제로 쪼개서 푸는 방식이다.
직관적으로, 바로 봐도 답이 나올 수 있는 정도로 작은 단위로 쪼갠다.
이 문제는 dy(dynamic)이라는 배열을 만들어 문제를 푼다.
**점화식**을 이해하면 좋다.
배열로 예를 들면 다음과 같다.

```js
dy[n] = dy[n - 1] + 3;
```

n번쨰의 답이 n-1번째에서 3을 더하면 답이 되듯이,
기준이 되는 인덱스(n)에서 근처에 있는 인덱스들(n-1)과 관계가 있는 것이 배열에서 점화식이다.
이 문제를 점화식으로 풀이해보자면 !
7번째 계단까지 오르는 방법을 한 번에 구하는 것은 어렵다.
그런데 1번째와 2번째 계단을 오르는 경우의 가짓수를 구하는 방법은 어렵지 않다.
1번째 계단을 오르는 경우의 수는 1, 2번째 계단을 오르는 경우의 수는 2.
각각 dy 배열에 n번째를 n번 인덱스로 바꿔 값을 할당해준다.

```js
dy[1] = 1;
dy[2] = 2;
```

그리고 3번째 계단을 오르는 경우를 생각해보자.
3번째 계단을 오르는 경우의 수는 1번째 계단에서 가는 경우와 2번째 계단에서 가는 경우를 합한 값이다.
1번째 계단에서 3번째 계단을 가는 방법은 1번째 계단을 오르는 경우에서 2번 계단을 건너뛰고 바로 2 걸음으로 3으로 도착하는 경우로, 1번째 계단을 오른 경우의 수와 값이 동일하다.
왜 바로 1번째에서 바로 3번째로 가냐하면 2번째 계단을 밟으면 그건 2번째 계단을 가는 경우와 겹치기 때문이다.
그리고 2번째에서 3번째에서 가는 경우도 한 걸음만 더 가면 되므로, 기존 2번째 계단을 오른 경우의 수와 같다.

```js
dy[3] = dy[1] + dy[2];
```

즉, 3번째 계단의 경우의 수를 구한 것처럼 이 문제의 풀이는 n번째 가는 경우의 수는 n-1번째와 n-2번째 경우를 합해주는 것이다.

1번째와 2번째 경우는 이미 초기화를 해줬으므로, for문을 통해 해결하면 된다.
dy 배열은 구하려는 답에서 +1을 해야 1, 2, 3, 4번째 계단을 배열의 index와 같은 값으로 사용할 수 있다.

```js
function solution(stairs) {
  let answer = 0;
  let dy = Array.from({ length: stairs + 1 }, () => 0);
  dy[1] = 1;
  dy[2] = 2;
  // 2까지는 초기화 해준다.
  for (let i = 3; i <= stairs; i++) {
    dy[i] = dy[i - 1] + dy[i - 2];
  }
  answer = dy[stairs];
  return answer;
}

console.log(solution(7));
```

---

<br/>

## 2. 돌다리 건너기

## 21.08.28

### My solution 👩🏻‍💻

### Teacher's solution 👨‍🏫

---

<br/>

## 3. 최대부분증가수열(LIS)

## 21.08.29

### My solution 👩🏻‍💻

### Teacher's solution 👨‍🏫

---

<br/>

## 4. 동전교환(냅색 알고리즘)

## 21.08.30

### My solution 👩🏻‍💻

### Teacher's solution 👨‍🏫

---

<br/>

## 5. 최대점수 구하기(냅색을 이용한 조합)

## 21.08.31

### My solution 👩🏻‍💻

### Teacher's solution 👨‍🏫

---

<br/>
