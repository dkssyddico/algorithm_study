# LeetCode Algorithm I

## Day 1 Binary Search

### 704. Binary Search

이진 검색이란 데이터가 오름차순으로 정렬된 상태에서 특정 값을 찾는 알고리즘이다.
중간 값을 선택하여 찾는 값과 비교 후, 값이 작거나 크면 중간 값 이상 혹은 이하의 값은 모두 제외하고 또 새롭게 중간 값을 선택한다.  
처음에는 무조건 주어진 배열을 잘라야 한다고 생각했는데 splice나 slice해서 배열을 자르는 건 시간을 늘리는 일이었다.  
주어지는 배열에서 가장 왼쪽과 오른쪽 index를 지정해서 mid index를 만들고, mid 인덱스로 계속 값을 확인해나가면 되는 문제였다.

---

### 278. First Bad Version

역시 이진검색을 활용해서 푸는 문제.  
false가 나오면 bad version이 아니다. 그래서 범위를 더 높여줘야하기 때문에 mid + 1 이다.
true가 나오면 bad version인데, bad version에서 최소값을 찾아야 한다.  
그래서 right 값을 mid에서 -1 한 값으로 바꾸는 것이다.
따로 API 가 주어져서 LeetCode 에서 풀어야했음 ㅎ
이진 검색에선 계속 left, right, mid 변수를 만드는 것만 유의하면 될 것 같다!

---

### 35. Search Insert Position

이것 또한 이진검색을 하는 문제.
이건 정확한 값을 찾는게 아니라 양 옆의 값을 알아야 된다 생각해서 혼자 꼬아 생각했다.  
푸는 방식은 위의 두 문제와 같은데 값이 있어서 정확한 인덱스가 나올 수도 있고, 유사한 값 옆에 있을 수 있기 때문에 후자의 경우에는 left or right - 1 을 해줘야 한다.  
while문을 다 돌리게 되면 아이템이 하나가 담긴 배열이 리턴된다고 생각하면 된다.  
answer 라는 변수를 만들기보단 그대로 return 할 수 있는 값은 없는지 고민해보자.

---

<br>

## Day 2 Two Pointers

### 977. Squares of a Sorted Array

예전엔 map과 sort로 풀었는데, two pointer 문제라고 한다.

- two pointer로 풀었을 때
  nums 배열의 길이를 가지고 새 배열을 만든다.  
  배열에서 모든 아이템을 다 판별해야되니 배열의 length로 변수를 하나 만든다.  
  기본적인 건 이진 검색이랑 while문 돌리는 게 비슷하다.  
  가장 처음 인덱스와 마지막 인덱스를 비교해서 큰 수를 result의 k번 인덱스에 넣는다.  
  이때 l은 왼쪽, r은 오른쪽에서 출발하므로, 아이템의 대소 비교가 끝나면 l은 ++, r은 --해줘야한다.
  가장 작은 수는 끝까지 남아서 result의 제일 첫번째 인덱스에 들어가게 된다.

---
