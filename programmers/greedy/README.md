# 프로그래머스 그리디 문제

## 1. 체육복 (21.09.30)

문제는 여벌의 옷을 가진 학생과 잃어버린 학생이 같을 경우의 처리를 어떻게 해줘야 되냐가 관건이었다.  
while문을 돌려야 하나, for문을 돌려야 하나 했는데 array의 내장 함수를 충분히 이해하고 있다면 쉽게 할 수 있었다.

Array.indexOf()는 배열에서 지정된 요소를 찾을 수 있는 첫번째 인덱스를 반환하고, 만약에 없다면 -1를 반환한다.  
그리고 Array.filter(cb)은 주어진 콜백 함수를 통과하는 요소를 모아 새로운 함수를 만든다.  
filter와 indexOf를 통해 lost와 reserve에서 중복이 되는 요소를 제거할 수 있었다.  
이때 만약 중복이 되는 게 있다면 total에 꼭 더해줘야 한다.  
그리고 변수 i를 하나 선언해서 0을 한다음 i가 reserve의 길이보다 짧을 때까지 while문을 돌린다.  
역시 이때도 indexOf를 활용해서 만약에 reserve의 첫번째 아이템부터 -1, +1 해서 맞는 요소가 있다면 total, i에 1씩 더해주고, 그 요소를 제거해준다.  
만약 아무것도 해당하지 않으면 진행을 위해 i에 1을 더해준다.  
초반에 풀 때는 splice를 통해서 없애주는 거 까진 했는데 아직도 for, while문을 먼저 쓰려는 버릇이 있다.  
array 내장 함수 map, filter 이런 걸 최대한 응용하려고 해보자!!

### 참고 블로그

- [참고](https://velog.io/@yuna_song/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B2%B4%EC%9C%A1%EB%B3%B5%ED%83%90%EC%9A%95%EB%B2%95%EA%B7%B8%EB%A6%AC%EB%94%94)
- 이분은 중복에 대해 total을 더해주는 처리를 안해줬음. 그래도 array 내장 함수를 멋지게 응용하셔서 나도 따라했다.

---

<br>

## 2. 조이스틱

---

<br>

## 3. 큰 수 만들기

문제에서 요구하는 답은 전체 숫자가 문자열로 주어졌을 때 k개의 수를 제거하고 가장 큰 수를 리턴하는 것이다.  
즉, **답의 자릿수 = 문자열의 길이 - k 개**가 된다.
맨 처음 생각났던 풀이는 우선 문자열에서 k - 1개를 빼서 남은 앞자리 수에서 가장 큰 수를 구하는 것이었다.  
만약에 주어진 예제처럼 1924에서 2개를 뺀 가장 큰 수를 구하는 거라면, 192에서 가장 큰 수인 9를 구하는 것이다. 근데 이 다음부터 어떻게 남은 수를 빼서 큰 수를 구하는 지에 대해서는 약간 혼란이 왔다.  
어쩌면 바보같을 수도 있겠지만 문제가 greedy라고 해서 stack을 쓰면 안되는건 절대 아니었다.  
숫자를 쌓으면 된다고는 어렴풋하게 생각이 들었는데 ㅠㅠ  
여튼 풀이를 찾아보니 stack을 이용하는 풀이가 많았다. k가 그 자체로 빠져야 하는 수이기 때문에 이를 이용하면 된다.  
스택에 제일 먼저 number의 첫번째 아이템을 넣어주고 빼야할 수가 남을 때(k > 0), 그리고 스택에 가장 위에 있는 수와 number의 현재 인덱스의 수를 비교했을 때 현재 인덱스의 수가 크면 스택에서 빼준다.  
스택에서 뺐다는 의미는 숫자를 하나 제거했다는 의미이므로, k도 -1을 해준다. 약간 이 부분에서 탐욕스럽게 큰 수를 찾아나가기 때문에 그리디 문제로 분류되지 않았나 싶다. 그리고 그 현재 인덱스의 수도 스택에 다시 넣어준다. 이를 반복해서 만약 k가 0이 되버리면 그대로 join('')을 이용해서 답을 낼 수 있지만, k가 남았으면 뒷자리부터 k만큼 제거해준다. 아까 위에서 언급했듯이 답의 자릿수는 문자열의 길이에서 k개를 빼준 만큼이기 때문이다.

### Array.splice

Array.splice는 계속해서 이용하는 데 계속 헷갈리는게 약간 한심하다.

```js
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```

splice는 array 그 자체를 변형시키는 내장함수다.  
splice의 첫번째 인자는 배열의 변경을 시작할 인덱스를 나타낸다. 만약 음수인 경우에는 배열의 끝부분부터 시작한다. 배열의 길이보다 큰 값이면 실제 시작 인덱스는 배열의 길이로 설정된다.
두번째 deleteCount는 배열에서 제거할 요소의 수이다.
deleteCount를 생략하거나 값이 array.length - start보다 크면(start에서 시작해서 배열에 남아있는 요소의 숫자가 같거나 클 경우) start부터의 모든 요소를 제거한다.

### 참고 블로그

- [참고1](https://taesung1993.tistory.com/46)

---

<br>

## 4. 구명보트

처음엔 가장 작은 무게대로 순서대로 정렬하고 무게를 계속 합하면 된다고 생각했다.  
내가 만든 풀이에서는 그런식으로 짜봤는데 통과를 할 수 없었다.
그리고 애초에 무게가 초과했을 때 처리해주는 코드가 부족했다.
짝을 맞추는걸 생각했는데 무게가 다 제각각이면 짝을 만드는 것은 또 비효율적이라고 생각했다.  
그래서 다른 사람 풀이를 참고해보니, 문제 조건에서 구명보트는 최대 2명이 탈 수 있기 때문에 가장 무거운 사람과 가벼운 사람이 타는게 가장 많이 탈 수 있는 방법이라고 한다.  
진짜 for문도 응용할 수 있는게 무궁무진한 것 같다.  
코드를 보면 가장 무거운 사람과 가벼운 사람을 더해서 리미트보다 작으면 그 다음 작은 무게인 사람으로 갈 수 있게 하고, 그게 아니라면 제일 무거운 사람만 빠진다.  
그리고 for문 조건에서 answer를 하나씩 올려주는 것이 구명보트가 한 개씩 배정된다는 의미가 된다.  
오늘도 멋진 코드를 보았다. 배열을 볼 때 맨 처음 인덱스와 마지막 인덱스로 어떻게 풀 수 있을지 생각해봐야겠다.
조금 쉬운 문제가 아닐까 생각했는데 직접 구현하지 못해서 속이 쓰리고 왜케 코드를 못짤까 생각이 들어서 슬펐다. 그래도 안하는 거보다 다른 사람코드 보고 눈에 하나씩 익혀나가면 언젠가는 나도 조금은 술술 문제를 풀 수 있지 않을까 기대해본다.

### 참고 블로그

- [참고1](https://jsikim1.tistory.com/152)
  - 구명보트가 작아서 최대 2명씩 밖에 탈 수 없기 때문에 가장 많이 탈 수 있는 방법은 가장 무거운 사람과 가장 가벼운 사람이 타는 방법 뿐일 것입니다. 그러므로 무게 순으로 정렬시킨 다음,가장 무거운 사람과 가장 가벼운 사람의 무게 합이 무게 제한 보다 낮으면 두 사람이 빠지고 구명보트 개수를 추가하고, 그렇지 않으면 가장 무거운 사람만 빠지고 구명보트 개수를 추가하면 됩니다. 이 과정을 반복한 뒤 추가된 구명보트의 총 개수를 반환합니다.

---

<br>

## 5. 단속 카메라

시작점을 구하고 다음 차량의 진입점이나 진출 시점이랑 비교해줘야된다는 건 금방 깨달았다.
하지만 푸는 방법에 대해서 제대로 구현하지 못했다.
while문을 이용해서 풀려고 했음.
참고한 풀이처럼 범위가 겹치면 시작점을 갱신해주고,
겹치는 부분이 하나도 없으면 카메라를 하나 설치해준다는 의미로 1개를 더해주고 하면 된다.
이제 어떻게 풀어야될지는 조금 감이 오는데 직접 구현이 문제인듯 ㅜ

### 참고 블로그

- [참고1](https://haerang94.tistory.com/338)

---

<br>
